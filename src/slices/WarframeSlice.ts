import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";

import { LOADING_STATE } from "../constants/Constants";
import { RootState } from "../store";

const MANIFEST_URL = "https://content.warframe.com/PublicExport/Manifest/";

// export const EXPORT_CUSTOMS_EN = "ExportCustoms_en";
// export const EXPORT_DRONES_EN = "ExportDrones_en";
// export const EXPORT_FLAVOUR_EN = "ExportFlavour_en";
// export const EXPORT_FUSIONBUNDLES_EN = "ExportFusionBundles_en";
// export const EXPORT_GEAR_EN = "ExportGear_en";
// export const EXPORT_KEYS_EN = "ExportKeys_en";
// export const EXPORT_RECIPES_EN = "ExportRecipes_en";
// export const EXPORT_REGIONS_EN = "ExportRegions_en";
// export const EXPORT_RELICARCANE_EN = "ExportRelicArcane_en";
// export const EXPORT_RESOURCES_EN = "ExportResources_en";
// export const EXPORT_SENTINELS_EN = "ExportSentinels_en";
// export const EXPORT_SORTIEREWARDS_EN = "ExportSortieRewards_en";
// export const EXPORT_UPGRADES_EN = "ExportUpgrades_en";
// export const EXPORT_WARFRAMES_EN = "ExportWarframes_en";
export const EXPORT_WEAPONS_EN = "ExportWeapons_en";
// export const EXPORT_MANIFEST = "ExportManifest";

export type WarframeExports = { [key: string]: [] };

export interface WarframeState {
  value: number;
  warframeExportStatus: LOADING_STATE;
  warframeExports: WarframeExports;
}

const initialState: WarframeState = {
  value: 0,
  warframeExportStatus: LOADING_STATE.IDLE,
  warframeExports: {},
};

const EXPORT_NAMES = [
  "ExportCustoms_en.json!00_eMmfFW0cBmhMgKCVg4OrVQ",
  "ExportDrones_en.json!00_LZKVJWzyNlEXy-hI3mpGnA",
  "ExportFlavour_en.json!00_ZncLtAPejPvNOCq-KayyhQ",
  "ExportFusionBundles_en.json!00_mievusFTvE1yg4jxseyL9w",
  "ExportGear_en.json!00_4dR4N93qX0d8hVBF3cFTGQ",
  "ExportKeys_en.json!00_ejrRZxo69KE2kJ5H9RtfAA",
  "ExportRecipes_en.json!00_PfGDS+9s51CjAENFDiIDeA",
  "ExportRegions_en.json!00_LwDkCjVYlvTWc0LozQroaw",
  "ExportRelicArcane_en.json!00_VOr3hNbwwZazos-HVr6+PQ",
  "ExportResources_en.json!00_HLVPCm5NzBeShq-q8dh+hg",
  "ExportSentinels_en.json!00_77HyQHJYXKRhQNFHDQDFlQ",
  "ExportSortieRewards_en.json!00_vhEG53WKxus2ogHEGP3fWw",
  "ExportUpgrades_en.json!00_4hLbuBsHeWHphpCSUnTy2Q",
  "ExportWarframes_en.json!00_SEhDH31H5ZuNUsCMx19ttQ",
  "ExportWeapons_en.json!00_x2GywzLibmHZggtRYQkeIw",
  "ExportManifest.json!00_M1J0bDB945QmWfunK2Hiqw",
];

/**
 * Fetch all the export files from the Warframe API and save them to redux state.
 */
export const fetchExports = createAsyncThunk("counter/fetchExports", async () => {
  const fetchExportJson = async (exportName: string): Promise<[]> => {
    const response = await fetch(`${MANIFEST_URL}${exportName}`);
    const responseText = await response.text();
    const responseTextCleaned = responseText.replace(/[\n\r]/g, "");
    const responseJson = JSON.parse(responseTextCleaned);
    return responseJson;
  };

  const exports: WarframeExports = {};

  await Promise.all(
    EXPORT_NAMES.map(async (exportName) => {
      const export_key = exportName.split(".json")[0];
      const exportJson = await fetchExportJson(exportName);

      exports[export_key] = exportJson;
    })
  );

  return exports;
});

export const warframeSlice = createSlice({
  name: "warframe",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: (state: WarframeState) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1;
    },
    decrement: (state: WarframeState) => {
      state.value -= 1;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state: WarframeState, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchExports.pending, (state) => {
        state.warframeExportStatus = LOADING_STATE.LOADING;
      })
      .addCase(fetchExports.fulfilled, (state, action) => {
        state.warframeExportStatus = LOADING_STATE.IDLE;
        state.warframeExports = action.payload;
      })
      .addCase(fetchExports.rejected, (state) => {
        state.warframeExportStatus = LOADING_STATE.FAILED;
      });
  },
});

export const { increment, decrement, incrementByAmount } = warframeSlice.actions;

export const selectWarframeExportStatus = (state: RootState) => state.warframe.warframeExportStatus;
export const selectWarframeExports = (state: RootState) => state.warframe.warframeExports;

export default warframeSlice.reducer;
